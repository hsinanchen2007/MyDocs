/* 
** 把一個值插入到一個雙向連結串列，
** rootp是一個指向根節點的指標，
** value是欲插入的新值。
** 返回值：如果欲插值原先已存在於連結串列中，函數返回0；
** 如果記憶體不足導致無法插入，函數返回-1；
** 如果插入成功，函數返回1。
*/
#include <stdlib.h>
#include <stdio.h>
#include "doubly_linked_list_node.h"

int
dll_insert( Node *rootp, int value )
{
    Node  *this;
    Node  *next;
    Node  *newnode;

    /* 
    ** 查看value是否已經存在於連結串列中，如果是就返回。 
    ** 否則，為新值建立一個新節點（"newnode"將指向它）。
    ** "this"將指向應該在新節點之前的那個節點，
    ** "next"將指向應該在新節點之後的那個節點。
    */
    for( this = rootp; (next = this->fwd) != NULL; this = next ){
        if( next->value == value )
            return 0;
        if( next->value > value )
            break;
}
newnode = (Node *)malloc( sizeof( Node ) );
if( newnode == NULL )
    return -1;
newnode->value = value;

/* 
** 把新值添加到連結串列中。
*/
if( next != NULL ){
/* 
** 情況1或2:並非位於連結串列尾部。
*/
        if( this != rootp ){   /* 情況1:並非位於連結串列起始位置 */
            newnode->fwd = next;
            this->fwd = newnode;
            newnode->bwd = this;
            next->bwd = newnode;
        }
        else {                 /* 情況2:位於連結串列起始位置 */
            newnode->fwd = next;
            rootp->fwd = newnode;
            newnode->bwd = NULL;
            next->bwd = newnode;
        }
    }
    else {
    /* 
    ** 情況3或4: 位於連結串列尾部。
    */
        if( this != rootp ){   /* 情況3:並非位於連結串列起始位置 */
            newnode->fwd = NULL;
            this->fwd = newnode;
            newnode->bwd = this;
            rootp->bwd = newnode;
        }
        else {                 /* 情況4:位於連結串列起始位置 */
            newnode->fwd = NULL;
            rootp->fwd = newnode;
            newnode->bwd = NULL;
            rootp->bwd = newnode;
        }
    }
    return 1;
}

