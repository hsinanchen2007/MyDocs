/*
** 一個使用靜態陣列實作的二元搜尋樹。
** 陣列的長度只能透過修改#define定義
** 並對模組進行重新編譯來實作。
*/
#include "tree.h"
#include <assert.h>
#include <stdio.h>

#define TREE_SIZE 100 /* Max # of values in the tree */
#define ARRAY_SIZE    ( TREE_SIZE + 1 )

/*
** 用於儲存樹的所有節點的陣列。
*/
static TREE_TYPE tree[ ARRAY_SIZE ];

/*
** left_child  
** 計算一個節點左孩子的索引。
*/
static int
left_child( int current )
{
        return current * 2;
}

/*
** right_child
** 計算一個節點右孩子的索引。
*/
static int
right_child( int current )
{
        return current * 2 + 1;
}

/*
** insert 
*/
void
insert( TREE_TYPE value )
{
        int    current;

        /* 
        ** 確保值為非零，因為零用於提示一個未使用的節點。 
        */
        assert( value != 0 );

        /*
        ** 從根節點開始。 
        */
        current = 1;

        /*
        ** 從合適的子樹開始，直到到達一個葉節點。 
        */
        while( tree[ current ] != 0 ){
        /*
        ** 根據情況，進入葉節點或右子樹(確信未出現重複的值)。 
        */
                if( value < tree[ current ] )
                        current = left_child( current );
                else {
                        assert( value != tree[ current ] );
                        current = right_child( current );
                }
                assert( current < ARRAY_SIZE );
        }

        tree[ current ] = value;
}

/*
** find 
*/
TREE_TYPE *
find( TREE_TYPE value )
{
        int    current;

        /*
        ** 從根節點開始。直到找到那個值，進入合適的子樹。 
        */
        current = 1;

        while( current < ARRAY_SIZE && tree[ current ] != value ){
        /*
        ** 根據情況，進入左子樹或右子樹。 
        */
            if( value < tree[ current ] )
                    current = left_child( current );
            else
                    current = right_child( current );
        }
        if( current < ARRAY_SIZE )
                return tree + current;
        else
                return 0;
}

/*
** do_pre_order_traverse
** 執行一層前序巡訪，
** 這個幫助函數用於保存當前正在處理的節點的資訊，
** 它並不是使用者介面的一部分。
*/
static void
do_pre_order_traverse( int current,
    void (*callback)( TREE_TYPE value ) )
{
            if( current < ARRAY_SIZE && tree[ current ] != 0 ){
                callback( tree[ current ] );
                do_pre_order_traverse( left_child( current ),
                    callback );
                do_pre_order_traverse( right_child( current ),
                    callback );
            }
}

/*
** pre_order_traverse  
*/
void
pre_order_traverse( void (*callback)( TREE_TYPE value ) )
{
    do_pre_order_traverse( 1, callback );
}


